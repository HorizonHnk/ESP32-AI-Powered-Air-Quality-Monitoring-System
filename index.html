<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 AI Assistant</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #ffffff; color: #1a202c; min-height: 100vh; display: flex; flex-direction: column; font-weight: 400; letter-spacing: -0.01em; }
        
        .header { background: linear-gradient(90deg, #e2e8f0, #f1f5f9); padding: clamp(8px, 2vw, 16px) clamp(12px, 3vw, 20px); display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); color: #1a202c; border-bottom: 1px solid #d1d5db; flex-wrap: wrap; gap: clamp(8px, 2vw, 12px); }
        .header h1 { font-size: clamp(14px, 3.5vw, 20px); font-weight: 600; order: 1; }
        .header-controls { display: flex; gap: clamp(4px, 1vw, 8px); align-items: center; flex-wrap: wrap; order: 2; }
        
        .nav-btn, .call-btn, .video-call-btn, .clear-btn { background: linear-gradient(45deg, #4f46e5, #7c3aed); border: none; color: white; padding: clamp(6px, 1.5vw, 10px) clamp(10px, 2.5vw, 16px); border-radius: clamp(12px, 3vw, 20px); cursor: pointer; font-size: clamp(10px, 2.2vw, 14px); font-weight: 500; display: flex; align-items: center; gap: clamp(4px, 1vw, 6px); transition: all 0.3s ease; text-decoration: none; white-space: nowrap; }
        .call-btn { background: linear-gradient(45deg, #10b981, #059669); }
        .video-call-btn { background: linear-gradient(45deg, #7c3aed, #6d28d9); }
        .clear-btn { background: linear-gradient(45deg, #f59e0b, #d97706); }
        .settings-btn { background: rgba(79, 70, 229, 0.1); border: none; color: #4f46e5; padding: clamp(6px, 1.5vw, 8px) clamp(10px, 2.5vw, 14px); border-radius: clamp(10px, 2.5vw, 16px); cursor: pointer; font-size: clamp(10px, 2.2vw, 13px); transition: all 0.3s ease; }
        
        .nav-btn:hover, .call-btn:hover, .video-call-btn:hover, .clear-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .settings-btn:hover { background: rgba(79, 70, 229, 0.2); color: #3730a3; }
        .call-btn.calling, .video-call-btn.calling { background: linear-gradient(45deg, #ef4444, #dc2626); animation: pulse-call 2s infinite; }
        @keyframes pulse-call { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        
        .video-call-interface { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; z-index: 2000; flex-direction: column; color: white; }
        .video-call-header { padding: clamp(8px, 2vw, 16px); text-align: center; background: rgba(0,0,0,0.3); }
        .video-call-content { flex: 1; display: flex; position: relative; overflow: hidden; }
        .video-main { flex: 1; display: flex; align-items: center; justify-content: center; position: relative; min-height: 50vh; }
        .user-video { width: 100%; height: 100%; object-fit: cover; background: #2a2a2a; }
        .video-sidebar { width: 100%; background: rgba(0,0,0,0.5); display: flex; flex-direction: column; padding: clamp(8px, 2vw, 16px); max-height: 50vh; overflow-y: auto; }
        .ai-video-avatar { width: clamp(50px, 10vw, 80px); height: clamp(50px, 10vw, 80px); border-radius: 50%; background: linear-gradient(45deg, #10b981, #059669); display: flex; align-items: center; justify-content: center; font-size: clamp(20px, 5vw, 32px); margin: 0 auto clamp(8px, 2vw, 16px); animation: breath 3s ease-in-out infinite; }
        @keyframes breath { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .video-status { text-align: center; margin-bottom: clamp(4px, 1vw, 8px); font-size: clamp(12px, 2.5vw, 16px); }
        .video-duration { text-align: center; opacity: 0.8; margin-bottom: clamp(8px, 2vw, 16px); font-size: clamp(10px, 2vw, 14px); }
        .video-controls { display: flex; gap: clamp(6px, 1.5vw, 10px); justify-content: center; margin-bottom: clamp(8px, 2vw, 16px); flex-wrap: wrap; }
        .video-control-btn { width: clamp(32px, 6vw, 45px); height: clamp(32px, 6vw, 45px); border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: clamp(14px, 3vw, 18px); transition: all 0.3s ease; color: white; }
        .video-mute-btn, .video-camera-btn, .video-switch-camera-btn { background: rgba(255, 255, 255, 0.2); }
        .video-mute-btn.muted, .video-camera-btn.off { background: #ef4444; }
        .video-switch-camera-btn { background: rgba(34, 197, 94, 0.8); }
        .video-switch-camera-btn:hover { background: rgba(34, 197, 94, 1); transform: scale(1.1); }
        .video-screenshot-btn { background: rgba(124, 58, 237, 0.8); }
        .video-screenshot-btn:hover { background: rgba(124, 58, 237, 1); transform: scale(1.1); }
        .video-end-btn { background: #ef4444; }
        .video-end-btn:hover { background: #dc2626; transform: scale(1.1); }
        .video-transcript { flex: 1; background: rgba(255, 255, 255, 0.1); border-radius: clamp(8px, 2vw, 12px); padding: clamp(8px, 2vw, 12px); overflow-y: auto; font-size: clamp(10px, 2vw, 13px); line-height: 1.4; min-height: 80px; }
        .video-analysis-indicator { position: absolute; top: clamp(8px, 2vw, 16px); left: clamp(8px, 2vw, 16px); background: rgba(124, 58, 237, 0.9); color: white; padding: clamp(6px, 1.5vw, 10px) clamp(8px, 2vw, 12px); border-radius: clamp(12px, 3vw, 16px); display: none; align-items: center; gap: clamp(4px, 1vw, 6px); font-size: clamp(10px, 2vw, 12px); font-weight: 500; }
        .analysis-pulse { width: clamp(6px, 1.2vw, 8px); height: clamp(6px, 1.2vw, 8px); background: white; border-radius: 50%; animation: pulse 1.5s infinite; }
        .video-capture-canvas { display: none; }
        
        .call-interface { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 2000; flex-direction: column; justify-content: center; align-items: center; color: white; padding: clamp(16px, 4vw, 32px); }
        .call-content { text-align: center; max-width: clamp(280px, 80vw, 400px); padding: clamp(16px, 4vw, 32px); }
        .call-avatar { width: clamp(80px, 15vw, 120px); height: clamp(80px, 15vw, 120px); border-radius: 50%; background: rgba(255, 255, 255, 0.2); display: flex; align-items: center; justify-content: center; font-size: clamp(32px, 7vw, 50px); margin: 0 auto clamp(16px, 4vw, 24px); animation: breath 3s ease-in-out infinite; }
        .call-status { font-size: clamp(18px, 4vw, 24px); font-weight: 600; margin-bottom: clamp(6px, 1.5vw, 10px); }
        .call-duration { font-size: clamp(14px, 3vw, 18px); opacity: 0.9; margin-bottom: clamp(16px, 4vw, 24px); }
        .call-controls { display: flex; gap: clamp(12px, 3vw, 18px); justify-content: center; margin-bottom: clamp(16px, 4vw, 24px); flex-wrap: wrap; }
        .call-control-btn { width: clamp(45px, 8vw, 60px); height: clamp(45px, 8vw, 60px); border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: clamp(18px, 4vw, 24px); transition: all 0.3s ease; }
        .mute-btn { background: rgba(255, 255, 255, 0.2); color: white; }
        .mute-btn.muted { background: #ef4444; }
        .end-call-btn { background: #ef4444; color: white; }
        .end-call-btn:hover { background: #dc2626; transform: scale(1.1); }
        .call-transcript { background: rgba(255, 255, 255, 0.1); border-radius: clamp(10px, 2.5vw, 15px); padding: clamp(12px, 3vw, 20px); max-height: clamp(150px, 30vh, 200px); overflow-y: auto; text-align: left; font-size: clamp(12px, 2.5vw, 14px); line-height: 1.5; }
        .transcript-entry { margin-bottom: clamp(8px, 2vw, 12px); padding: clamp(6px, 1.5vw, 10px); border-radius: clamp(6px, 1.5vw, 8px); }
        .transcript-user { background: rgba(255, 255, 255, 0.1); }
        .transcript-ai { background: rgba(255, 255, 255, 0.05); }
        
        .listening-indicator, .speaking-indicator { position: fixed; bottom: clamp(16px, 4vw, 30px); left: 50%; transform: translateX(-50%); color: white; padding: clamp(8px, 2vw, 12px) clamp(12px, 3vw, 20px); border-radius: clamp(12px, 3vw, 20px); display: none; align-items: center; gap: clamp(6px, 1.5vw, 8px); font-weight: 500; box-shadow: 0 4px 16px rgba(0,0,0,0.3); font-size: clamp(12px, 2.5vw, 14px); }
        .listening-indicator { background: rgba(16, 185, 129, 0.9); }
        .speaking-indicator { background: rgba(79, 70, 229, 0.9); }
        .listening-pulse { width: clamp(8px, 2vw, 12px); height: clamp(8px, 2vw, 12px); background: white; border-radius: 50%; animation: pulse 1.5s infinite; }
        .speaking-bars { display: flex; gap: clamp(2px, 0.5vw, 3px); align-items: center; }
        .speaking-bar { width: clamp(2px, 0.5vw, 3px); height: clamp(8px, 2vw, 12px); background: white; border-radius: 1px; animation: speaking 0.8s ease-in-out infinite; }
        .speaking-bar:nth-child(2) { animation-delay: 0.1s; }
        .speaking-bar:nth-child(3) { animation-delay: 0.2s; }
        .speaking-bar:nth-child(4) { animation-delay: 0.3s; }
        @keyframes speaking { 0%, 100% { height: clamp(3px, 0.8vw, 4px); } 50% { height: clamp(12px, 3vw, 16px); } }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        
        .chat-container { flex: 1; overflow-y: auto; padding: clamp(8px, 2vw, 16px); max-width: clamp(280px, 95vw, 900px); margin: 0 auto; width: 100%; }
        .message { margin-bottom: clamp(12px, 2.5vw, 18px); display: flex; gap: clamp(6px, 1.5vw, 12px); animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .message-avatar { width: clamp(24px, 5vw, 32px); height: clamp(24px, 5vw, 32px); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: clamp(12px, 2.5vw, 16px); flex-shrink: 0; }
        .user-avatar { background: linear-gradient(45deg, #4f46e5, #7c3aed); }
        .bot-avatar { background: linear-gradient(45deg, #10b981, #059669); }
        .message-content { flex: 1; background: #f1f5f9; padding: clamp(8px, 2vw, 14px) clamp(12px, 3vw, 18px); border-radius: clamp(10px, 2.5vw, 15px); border: 1px solid #d1d5db; position: relative; color: #1a202c; }
        .user-message .message-content { background: linear-gradient(45deg, #4f46e5, #7c3aed); color: white; }
        .bot-message .message-content { background: #f1f5f9; color: #1a202c; }
        .message-text { white-space: pre-wrap; line-height: 1.5; color: inherit; font-size: clamp(12px, 2.5vw, 15px); }
        .message-image { max-width: clamp(200px, 60vw, 300px); max-height: clamp(150px, 40vh, 250px); border-radius: clamp(6px, 1.5vw, 10px); margin-top: clamp(6px, 1.5vw, 10px); border: 1px solid #d1d5db; height: auto; }
        .message-actions { display: flex; gap: clamp(6px, 1.5vw, 8px); margin-top: clamp(6px, 1.5vw, 10px); padding-top: clamp(6px, 1.5vw, 10px); border-top: 1px solid #e2e8f0; flex-wrap: wrap; }
        .action-btn { background: none; border: 1px solid #d1d5db; color: #64748b; padding: clamp(3px, 0.8vw, 5px) clamp(6px, 1.5vw, 10px); border-radius: clamp(8px, 2vw, 12px); cursor: pointer; font-size: clamp(9px, 2vw, 11px); transition: all 0.2s; }
        .action-btn:hover { color: #4f46e5; border-color: #4f46e5; background: rgba(79, 70, 229, 0.05); }
        
        .input-area { background: #f8fafc; border-top: 1px solid #d1d5db; padding: clamp(8px, 2vw, 16px); }
        .input-container { max-width: clamp(280px, 95vw, 900px); margin: 0 auto; display: flex; flex-direction: column; gap: clamp(8px, 2vw, 12px); }
        .input-row { display: flex; gap: clamp(6px, 1.5vw, 10px); align-items: flex-end; background: #ffffff; border: 1px solid #d1d5db; border-radius: clamp(12px, 3vw, 20px); padding: clamp(6px, 1.5vw, 10px) clamp(8px, 2vw, 12px); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .input-controls { display: flex; gap: clamp(4px, 1vw, 6px); }
        .control-btn { background: none; border: none; color: #64748b; cursor: pointer; padding: clamp(4px, 1vw, 6px); border-radius: 50%; transition: all 0.2s; font-size: clamp(14px, 3vw, 16px); min-width: clamp(28px, 6vw, 36px); min-height: clamp(28px, 6vw, 36px); display: flex; align-items: center; justify-content: center; }
        .control-btn:hover { color: #4f46e5; background: rgba(79, 70, 229, 0.1); }
        .control-btn.active { color: #4f46e5; background: rgba(79, 70, 229, 0.15); }
        .message-input { flex: 1; background: none; border: none; color: #1a202c; font-size: clamp(13px, 2.8vw, 15px); resize: none; outline: none; min-height: 18px; max-height: clamp(80px, 20vh, 120px); line-height: 1.4; }
        .message-input::placeholder { color: #64748b; }
        .send-btn { background: #4f46e5; border: none; color: white; padding: clamp(4px, 1vw, 6px); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; min-width: clamp(28px, 6vw, 36px); min-height: clamp(28px, 6vw, 36px); }
        .send-btn:hover:not(:disabled) { background: #3730a3; transform: scale(1.05); }
        .send-btn:disabled { background: #9ca3af; cursor: not-allowed; }
        
        .image-preview { display: none; max-width: clamp(120px, 25vw, 150px); max-height: clamp(90px, 20vh, 120px); border-radius: clamp(6px, 1.5vw, 10px); border: 2px solid #d1d5db; }
        .recording-indicator { display: none; align-items: center; gap: clamp(6px, 1.5vw, 8px); color: #dc2626; font-size: clamp(11px, 2.2vw, 13px); padding: clamp(6px, 1.5vw, 8px) clamp(8px, 2vw, 12px); background: rgba(220, 38, 38, 0.1); border-radius: clamp(10px, 2.5vw, 16px); }
        .typing-indicator { display: none; gap: clamp(8px, 2vw, 12px); margin-bottom: clamp(12px, 2.5vw, 18px); }
        .typing-dots { display: flex; gap: clamp(3px, 0.8vw, 4px); padding: clamp(8px, 2vw, 12px) clamp(12px, 3vw, 16px); background: #f1f5f9; border-radius: clamp(10px, 2.5vw, 15px); border: 1px solid #d1d5db; }
        .typing-dot { width: clamp(4px, 1vw, 6px); height: clamp(4px, 1vw, 6px); background: #64748b; border-radius: 50%; animation: typing 1.5s infinite; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(clamp(-6px, -1.5vw, -8px)); } }
        .hidden-input { display: none; }
        .welcome-message { text-align: center; padding: clamp(16px, 4vw, 32px) clamp(12px, 3vw, 20px); color: #64748b; }
        .welcome-message h2 { margin-bottom: clamp(6px, 1.5vw, 10px); color: #4f46e5; font-size: clamp(16px, 3.5vw, 22px); }
        .welcome-message p { font-size: clamp(12px, 2.5vw, 15px); }
        
        .settings-panel { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; padding: clamp(16px, 4vw, 32px); }
        .settings-content { background: #f8fafc; padding: clamp(16px, 4vw, 30px); border-radius: clamp(10px, 2.5vw, 15px); width: min(clamp(280px, 85vw, 500px), 90vw); max-height: 90vh; overflow-y: auto; border: 1px solid #d1d5db; box-shadow: 0 10px 25px rgba(0,0,0,0.15); color: #1a202c; }
        .settings-content h3 { margin-bottom: clamp(12px, 3vw, 20px); color: #4f46e5; font-size: clamp(16px, 3.5vw, 20px); }
        input[type="password"], input[type="text"], input[type="range"], select { background: #ffffff; border: 1px solid #d1d5db; color: #1a202c; padding: clamp(6px, 1.5vw, 10px); border-radius: clamp(6px, 1.5vw, 8px); width: 100%; margin-bottom: clamp(6px, 1.5vw, 10px); font-size: clamp(12px, 2.5vw, 14px); }
        input[type="password"]:focus, input[type="text"]:focus, select:focus { outline: 2px solid #4f46e5; outline-offset: 2px; }
        label { display: block; margin-bottom: clamp(3px, 0.8vw, 5px); color: #64748b; font-size: clamp(11px, 2.2vw, 13px); }
        .form-group { margin-bottom: clamp(12px, 3vw, 18px); }
        .close-btn, .save-btn { border: none; color: white; padding: clamp(6px, 1.5vw, 10px) clamp(12px, 3vw, 18px); border-radius: clamp(6px, 1.5vw, 8px); cursor: pointer; font-size: clamp(11px, 2.2vw, 13px); }
        .close-btn { background: #ef4444; float: right; }
        .save-btn { background: #4f46e5; margin-right: clamp(6px, 1.5vw, 10px); }
        small { color: #64748b; font-size: clamp(9px, 2vw, 11px); }
        a { color: #4f46e5; }
        a:hover { color: #3730a3; text-decoration: underline; }
        
        @media (max-width: 320px) {
            .header { flex-direction: column; text-align: center; }
            .header-controls { justify-content: center; }
            .video-call-content { flex-direction: column; }
            .video-sidebar { width: 100%; max-height: 40vh; }
            .video-controls { gap: 4px; }
            .call-controls { gap: 8px; }
        }
        
        @media (min-width: 481px) and (max-width: 768px) {
            .video-call-content { flex-direction: row; }
            .video-sidebar { width: clamp(250px, 40vw, 300px); max-height: 100vh; }
        }
        
        @media (min-width: 769px) {
            .video-sidebar { width: clamp(300px, 35vw, 350px); }
        }
        
        @media (min-width: 1025px) {
            .video-sidebar { width: 350px; }
            .header h1 { font-size: 20px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü§ñ ESP32 AI Assistant</h1>
        <div class="header-controls">
            <button class="clear-btn" onclick="clearChat()" title="Clear Chat History">üóëÔ∏è Clear</button>
            <button class="call-btn" id="callBtn">üìû Call AI</button>
            <button class="video-call-btn" id="videoCallBtn">üìπ Video Call</button>
            <button class="settings-btn" onclick="openSettings()">Settings</button>
        </div>
    </div>

    <div class="video-call-interface" id="videoCallInterface">
        <div class="video-call-header">
            <div class="video-status" id="videoCallStatus">Connecting...</div>
            <div class="video-duration" id="videoCallDuration">00:00</div>
        </div>
        <div class="video-call-content">
            <div class="video-main">
                <video id="userVideo" class="user-video" autoplay muted playsinline></video>
                <canvas id="videoCaptureCanvas" class="video-capture-canvas"></canvas>
                <div class="video-analysis-indicator" id="videoAnalysisIndicator">
                    <div class="analysis-pulse"></div>AI Analyzing...
                </div>
            </div>
            <div class="video-sidebar">
                <div class="ai-video-avatar" id="videoCallAvatar">ü§ñ</div>
                <div class="video-controls">
                    <button class="video-control-btn video-mute-btn" id="videoMuteBtn" onclick="toggleVideoMute()" title="Mute/Unmute">üé§</button>
                    <button class="video-control-btn video-camera-btn" id="videoCameraBtn" onclick="toggleCamera()" title="Camera On/Off">üìπ</button>
                    <button class="video-control-btn video-switch-camera-btn" id="switchCameraBtn" onclick="switchCamera()" title="Switch Camera">üîÑ</button>
                    <button class="video-control-btn video-screenshot-btn" onclick="captureAndAnalyze()" title="Show AI What I'm Doing">üì∏</button>
                    <button class="video-control-btn" onclick="copyVideoTranscript()" title="Copy Conversation">üìã</button>
                    <button class="video-control-btn" onclick="speakVideoTranscript()" title="Read Conversation">üîä</button>
                    <button class="video-control-btn video-end-btn" onclick="endVideoCall()" title="End Call">üìû</button>
                </div>
                <div class="video-transcript" id="videoTranscript">
                    <div class="transcript-entry transcript-ai">
                        <strong>AI:</strong> Hi! I can see and hear you now. How can I help you today?
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="call-interface" id="callInterface">
        <div class="call-content">
            <div class="call-avatar" id="callAvatar">ü§ñ</div>
            <div class="call-status" id="callStatus">Connecting...</div>
            <div class="call-duration" id="callDuration">00:00</div>
            <div class="call-controls">
                <button class="call-control-btn mute-btn" id="muteBtn" onclick="toggleMute()" title="Mute/Unmute">üé§</button>
                <button class="call-control-btn" onclick="copyCallTranscript()" title="Copy Conversation">üìã</button>
                <button class="call-control-btn" onclick="speakCallTranscript()" title="Read Conversation Aloud">üîä</button>
                <button class="call-control-btn end-call-btn" onclick="endCall()" title="End Call">üìû</button>
            </div>
            <div class="call-transcript" id="callTranscript">
                <div class="transcript-entry transcript-ai">
                    <strong>AI:</strong> Hi! I'm ready to talk. How can I help you today?
                </div>
            </div>
        </div>
    </div>

    <div class="listening-indicator" id="listeningIndicator">
        <div class="listening-pulse"></div>Listening...
    </div>
    <div class="speaking-indicator" id="speakingIndicator">
        <div class="speaking-bars">
            <div class="speaking-bar"></div>
            <div class="speaking-bar"></div>
            <div class="speaking-bar"></div>
            <div class="speaking-bar"></div>
        </div>AI Speaking...
    </div>

    <div class="chat-container" id="chatContainer">
        <div class="welcome-message">
            <h2>Hello! I'm your ESP32 AI Assistant</h2>
            <p>I can help with air quality monitoring, sensor readings, and system setup. I also support text, images, voice, and video calls!</p>
        </div>
        
        <div class="message bot-message">
            <div class="message-avatar bot-avatar">ü§ñ</div>
            <div class="message-content">
                <div class="message-text"><strong>Current System Status:</strong>

Air Quality: Good (350 PPM)
Buzzer: Pattern 0 (Silent)
Fan: ON - 25% (Auto mode)
Data Points: 45/1440

Ask me about safety thresholds, hardware setup, upload images, or try voice/video calls!</div>
            </div>
        </div>
    </div>

    <div class="typing-indicator" id="typingIndicator">
        <div class="message-avatar bot-avatar">ü§ñ</div>
        <div class="typing-dots">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
        </div>
    </div>

    <div class="input-area">
        <div class="recording-indicator" id="recordingIndicator">
            <div class="pulse"></div>Recording... Click the mic again to stop
        </div>
        <div class="input-container">
            <img id="imagePreview" class="image-preview">
            <div class="input-row">
                <div class="input-controls">
                    <button class="control-btn" id="imageBtn" onclick="selectImage()" title="Upload image">üì∑</button>
                    <button class="control-btn" id="micBtn" onclick="toggleRecording()" title="Voice input">üé§</button>
                    <button class="control-btn" id="speakerBtn" onclick="toggleAutoSpeak()" title="Auto-speak responses">üîä</button>
                </div>
                <textarea class="message-input" id="messageInput" placeholder="Message AI Assistant..." rows="1" onkeydown="handleKeyDown(event)" oninput="autoResize(this)"></textarea>
                <button class="send-btn" id="sendBtn" onclick="sendMessage()" disabled>‚û§</button>
            </div>
        </div>
    </div>

    <div class="settings-panel" id="settingsPanel">
        <div class="settings-content">
            <h3>Settings</h3>
            <div class="form-group">
                <label for="apiKeyInput">Google Gemini API Key</label>
                <input type="password" id="apiKeyInput" placeholder="Enter your API key">
                <small>Get your key from <a href="https://aistudio.google.com/" target="_blank">Google AI Studio</a></small>
            </div>
            <div class="form-group">
                <label for="voiceSelect">Voice for Text-to-Speech</label>
                <select id="voiceSelect"></select>
            </div>
            <div class="form-group">
                <label for="speechRate">Speech Rate</label>
                <input type="range" id="speechRate" min="0.5" max="2" step="0.1" value="1.0">
                <span id="rateValue">1.0</span>
            </div>
            <div>
                <button class="save-btn" onclick="saveSettings()">Save</button>
                <button class="close-btn" onclick="closeSettings()">Close</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" class="hidden-input" accept="image/*" onchange="handleImageSelect()">

    <script>
        let geminiApiKey = 'Your_Gemini_Api_Key';
        let selectedImage = null;
        let isRecording = false;
        let autoSpeak = false;
        let voices = [];
        let selectedVoice = null;
        let speechRate = 1.0;
        let recognition = null;
        let continuousRecognition = null;
        let isInCall = false;
        let isMuted = false;
        let callStartTime = null;
        let callDurationInterval = null;
        let conversationHistory = [];
        let isAISpeaking = false;
        let isListeningForUser = false;
        let currentUtterance = null;
        let isInVideoCall = false;
        let isCameraOn = false;
        let videoStream = null;
        let videoAnalysisInterval = null;
        let lastAnalysisTime = 0;
        let analysisCount = 0;
        let isProcessingResponse = false;
        let lastTranscript = '';
        let lastResponseTime = 0;
        let recognitionTimeoutId = null;
        let messageCounter = 0;
        let currentPlayingId = null;
        let microphonePermissionGranted = false;
        let availableCameras = [];
        let currentCamera = 'user';

        const systemInstructions = `You are a helpful AI assistant connected to an ESP32 air quality monitoring system. 

CURRENT SYSTEM DATA:
- Air Quality: Good
- CO2 Level: 350 PPM
- Fan Status: ON at 25% (Auto mode)
- Buzzer: Pattern 0 (Silent)
- Data Points: 45/1440

SAFETY THRESHOLDS:
- Below 250 PPM: Excellent air quality
- 250-500 PPM: Good air quality (Normal indoor levels)
- 500-750 PPM: CAUTION - Ventilation recommended
- 750-1000 PPM: WARNING - Poor air quality, increase ventilation
- Above 1000 PPM: DANGER - Immediate action required

HARDWARE SETUP:
- ESP32 DevKit microcontroller
- MQ-135 or equivalent CO2/air quality sensor
- Fan control system (PWM-based speed control)
- Buzzer for audio alerts
- Web-based interface for monitoring

You can discuss air quality, explain sensor readings, provide ventilation recommendations, and help with system setup. You can also discuss any other topics. KEEP RESPONSES SHORT (2-3 sentences max for voice/video calls).`;

        document.addEventListener('DOMContentLoaded', function() {
            initializeVoices();
            initializeSpeechRecognition();
            initializeContinuousSpeechRecognition();
            loadSettings();
            loadChatHistory();
            requestMicrophonePermission();
            enumerateCameras();
            document.getElementById('callBtn').addEventListener('click', toggleCall);
            document.getElementById('videoCallBtn').addEventListener('click', toggleVideoCall);
            
            const messageInput = document.getElementById('messageInput');
            messageInput.addEventListener('input', function() {
                autoResize(this);
                updateSendButton();
            });
            
            const speechRateSlider = document.getElementById('speechRate');
            speechRateSlider.addEventListener('input', function() {
                document.getElementById('rateValue').textContent = this.value;
                speechRate = parseFloat(this.value);
            });
            
            if ('speechSynthesis' in window) {
                speechSynthesis.addEventListener('voiceschanged', initializeVoices);
            }
        });

        async function enumerateCameras() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                    console.error('enumerateDevices not supported');
                    return;
                }
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');
                console.log('Available cameras:', availableCameras.length);
                
                const switchBtn = document.getElementById('switchCameraBtn');
                if (availableCameras.length > 1 && switchBtn) {
                    switchBtn.style.display = 'flex';
                } else if (switchBtn) {
                    switchBtn.style.display = 'none';
                }
            } catch (error) {
                console.error('Error enumerating cameras:', error);
            }
        }

        async function switchCamera() {
            if (!isInVideoCall || !isCameraOn) {
                alert('Please start a video call and turn on the camera first.');
                return;
            }
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('Camera access is not supported in your browser.');
                return;
            }
            
            try {
                const switchBtn = document.getElementById('switchCameraBtn');
                if (switchBtn) {
                    switchBtn.disabled = true;
                    switchBtn.innerHTML = '‚è≥';
                }
                
                const newCamera = currentCamera === 'user' ? 'environment' : 'user';
                console.log('Switching from', currentCamera, 'to', newCamera);
                
                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                }
                
                const constraints = {
                    video: {
                        facingMode: { exact: newCamera },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                };
                
                try {
                    videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (exactError) {
                    console.log('Exact facingMode failed, trying ideal:', exactError.name);
                    const fallbackConstraints = {
                        video: {
                            facingMode: newCamera,
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        },
                        audio: true
                    };
                    videoStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
                }
                
                const videoElement = document.getElementById('userVideo');
                videoElement.srcObject = videoStream;
                currentCamera = newCamera;
                
                if (switchBtn) {
                    switchBtn.disabled = false;
                    switchBtn.innerHTML = 'üîÑ';
                }
                
                const feedbackMsg = currentCamera === 'environment' ? 'Switched to back camera' : 'Switched to front camera';
                addToVideoTranscript('ai', 'üì∑ ' + feedbackMsg);
                console.log('Camera switched successfully to:', currentCamera);
            } catch (error) {
                console.error('Error switching camera:', error);
                const switchBtn = document.getElementById('switchCameraBtn');
                if (switchBtn) {
                    switchBtn.disabled = false;
                    switchBtn.innerHTML = 'üîÑ';
                }
                
                if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    alert('Camera not found. Your device may not have a ' + (newCamera === 'environment' ? 'back' : 'front') + ' camera.');
                } else if (error.name === 'NotAllowedError') {
                    alert('Camera access denied. Please allow camera access and try again.');
                } else if (error.name === 'OverconstrainedError') {
                    alert('The requested camera is not available. Your device may not have a ' + (newCamera === 'environment' ? 'back' : 'front') + ' camera.');
                } else {
                    alert('Failed to switch camera: ' + error.message);
                }
            }
        }

        async function requestMicrophonePermission() {
            try {
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('Microphone permission granted');
                    microphonePermissionGranted = true;
                    stream.getTracks().forEach(track => track.stop());
                }
            } catch (error) {
                console.log('Microphone permission not granted yet:', error.name);
                microphonePermissionGranted = false;
            }
        }

        function initializeVoices() {
            if ('speechSynthesis' in window) {
                function loadVoices() {
                    voices = speechSynthesis.getVoices();
                    const voiceSelect = document.getElementById('voiceSelect');
                    voiceSelect.innerHTML = '<option value="">Default Voice</option>';
                    voices.forEach((voice, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = voice.name + ' (' + voice.lang + ')';
                        voiceSelect.appendChild(option);
                    });
                }
                loadVoices();
                speechSynthesis.onvoiceschanged = loadVoices;
            }
        }

        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onstart = function() {
                    console.log('Speech recognition started');
                    startRecording();
                };
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    console.log('Transcript received:', transcript);
                    document.getElementById('messageInput').value = transcript;
                    autoResize(document.getElementById('messageInput'));
                    updateSendButton();
                    stopRecording();
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    stopRecording();
                    if (event.error === 'not-allowed') {
                        alert('Microphone access denied. Please allow microphone access in your browser settings and try again.');
                    } else if (event.error === 'network') {
                        console.log('Network error - speech recognition requires internet connection');
                        alert('Speech recognition requires an internet connection. Please check your connection and try again.');
                    } else if (event.error === 'no-speech') {
                        console.log('No speech detected');
                    } else {
                        console.log('Speech recognition error:', event.error);
                    }
                };
                
                recognition.onend = function() {
                    stopRecording();
                };
            } else {
                console.log('Speech recognition not supported in this browser.');
            }
        }

        function initializeContinuousSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                continuousRecognition = new SpeechRecognition();
                continuousRecognition.continuous = true;
                continuousRecognition.interimResults = false;
                continuousRecognition.lang = 'en-US';
                continuousRecognition.maxAlternatives = 1;
                
                continuousRecognition.onstart = function() {
                    console.log('Continuous speech recognition started');
                };
                
                continuousRecognition.onresult = function(event) {
                    if ((!isInCall && !isInVideoCall) || isMuted || isAISpeaking || isProcessingResponse) {
                        return;
                    }
                    
                    clearTimeout(recognitionTimeoutId);
                    const lastResult = event.results[event.results.length - 1];
                    
                    if (lastResult.isFinal) {
                        const transcript = lastResult[0].transcript.trim();
                        console.log('Final transcript received:', transcript);
                        
                        if (transcript && transcript.length > 2 && transcript !== lastTranscript) {
                            const now = Date.now();
                            if (now - lastResponseTime > 3000) {
                                lastTranscript = transcript;
                                lastResponseTime = now;
                                
                                recognitionTimeoutId = setTimeout(() => {
                                    if (isInVideoCall) {
                                        handleVideoCallUserInput(transcript);
                                    } else if (isInCall) {
                                        handleCallUserInput(transcript);
                                    }
                                }, 800);
                            }
                        }
                    }
                };
                
                continuousRecognition.onerror = function(event) {
                    console.error('Continuous speech recognition error:', event.error);
                    
                    if (event.error === 'not-allowed') {
                        alert('Microphone access denied. Please allow microphone access and try again.');
                        if (isInCall) endCall();
                        if (isInVideoCall) endVideoCall();
                        return;
                    }
                    
                    if (event.error === 'no-speech') {
                        console.log('No speech detected, continuing...');
                        return;
                    }
                    
                    if ((isInCall || isInVideoCall) && !isMuted && !isAISpeaking && !isProcessingResponse) {
                        setTimeout(() => {
                            if ((isInCall || isInVideoCall) && !isMuted && !isAISpeaking && !isProcessingResponse) {
                                console.log('Restarting speech recognition after error');
                                if (isInVideoCall) {
                                    startVideoListening();
                                } else {
                                    startListening();
                                }
                            }
                        }, 1500);
                    }
                };
            } else {
                console.error('Speech recognition not supported in this browser');
            }
        }

        function clearChat() {
            if (confirm('Are you sure you want to clear the chat history?')) {
                const chatContainer = document.getElementById('chatContainer');
                const welcomeMessage = chatContainer.querySelector('.welcome-message');
                chatContainer.innerHTML = '';
                if (welcomeMessage) chatContainer.appendChild(welcomeMessage.cloneNode(true));
                localStorage.removeItem('chatHistory');
                messageCounter = 0;
                alert('Chat history cleared successfully!');
            }
        }

        function createMessageElement(sender, text, image, isError = false) {
            messageCounter++;
            const messageId = 'msg-' + messageCounter;
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + sender + '-message';
            messageDiv.id = messageId;
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar ' + sender + '-avatar';
            avatar.textContent = sender === 'user' ? 'üë§' : 'ü§ñ';
            
            const content = document.createElement('div');
            content.className = 'message-content';
            
            if (text) {
                const textDiv = document.createElement('div');
                textDiv.className = 'message-text';
                textDiv.textContent = text;
                if (isError) textDiv.style.color = '#dc2626';
                content.appendChild(textDiv);
            }
            
            if (image) {
                const imgElement = document.createElement('img');
                imgElement.className = 'message-image';
                const reader = new FileReader();
                reader.onload = function(e) {
                    imgElement.src = e.target.result;
                };
                reader.readAsDataURL(image);
                content.appendChild(imgElement);
            }
            
            if (sender === 'bot' && text && !isError) {
                const actions = document.createElement('div');
                actions.className = 'message-actions';
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'action-btn';
                copyBtn.textContent = 'üìã Copy';
                copyBtn.onclick = () => copyToClipboard(text);
                
                const speakBtn = document.createElement('button');
                speakBtn.className = 'action-btn speak-btn';
                speakBtn.textContent = 'üîä Speak';
                speakBtn.id = 'speak-' + messageId;
                speakBtn.onclick = () => speakMessage(text, speakBtn.id);
                
                actions.appendChild(copyBtn);
                actions.appendChild(speakBtn);
                content.appendChild(actions);
            }
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(content);
            saveChatHistory();
            return messageDiv;
        }

        function speakMessage(text, buttonId) {
            const button = document.getElementById(buttonId);
            
            if (!('speechSynthesis' in window)) {
                alert('Speech synthesis is not supported in your browser');
                return;
            }
            
            if (currentPlayingId && currentPlayingId !== buttonId) {
                speechSynthesis.cancel();
                resetSpeakButton(currentPlayingId);
            }
            
            if (button.textContent.includes('Stop')) {
                speechSynthesis.cancel();
                resetSpeakButton(buttonId);
                currentPlayingId = null;
                return;
            }
            
            currentPlayingId = buttonId;
            button.textContent = '‚è∏Ô∏è Stop';
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = speechRate;
            if (selectedVoice) utterance.voice = selectedVoice;
            
            utterance.onend = () => {
                resetSpeakButton(buttonId);
                currentPlayingId = null;
            };
            
            utterance.onerror = () => {
                resetSpeakButton(buttonId);
                currentPlayingId = null;
            };
            
            speechSynthesis.speak(utterance);
        }

        function resetSpeakButton(buttonId) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.textContent = 'üîä Speak';
            }
        }

        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            
            if (!message && !selectedImage) return;
            
            if (!geminiApiKey) {
                alert('Please set your API key in Settings first.');
                return;
            }
            
            messageInput.value = '';
            autoResize(messageInput);
            
            const imagePreview = document.getElementById('imagePreview');
            imagePreview.style.display = 'none';
            
            addUserMessage(message, selectedImage);
            const currentImage = selectedImage;
            selectedImage = null;
            updateSendButton();
            
            showTypingIndicator();
            
            try {
                const response = await callGeminiAPI(message, currentImage);
                hideTypingIndicator();
                
                if (response && response.candidates && response.candidates[0]) {
                    const botResponse = response.candidates[0].content.parts[0].text;
                    addBotMessage(botResponse);
                    
                    if (autoSpeak) {
                        speakText(botResponse);
                    }
                } else {
                    throw new Error('Invalid response format');
                }
            } catch (error) {
                hideTypingIndicator();
                let errorMessage = 'Sorry, I encountered an error: ' + error.message;
                addBotMessage(errorMessage, true);
            }
        }

        async function callGeminiAPI(text, image) {
            const parts = [];
            
            if (text && image) {
                parts.push({ text: systemInstructions + '\n\nUser message: ' + text + '\n\nPlease analyze the uploaded image and respond to the user\'s request.' });
                const base64Data = await fileToBase64(image);
                parts.push({ inline_data: { mime_type: image.type, data: base64Data } });
            } else if (text) {
                parts.push({ text: systemInstructions + '\n\nUser: ' + text });
            } else if (image) {
                parts.push({ text: systemInstructions + '\n\nPlease analyze this image and provide feedback.' });
                const base64Data = await fileToBase64(image);
                parts.push({ inline_data: { mime_type: image.type, data: base64Data } });
            }
            
            try {
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + geminiApiKey, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: parts }],
                        generationConfig: { temperature: 0.7, topK: 40, topP: 0.95, maxOutputTokens: 1024 }
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    throw new Error('API Error ' + response.status + ': ' + errorData);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Request failed:', error);
                throw error;
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function addUserMessage(text, image) {
            const chatContainer = document.getElementById('chatContainer');
            const messageDiv = createMessageElement('user', text, image);
            chatContainer.appendChild(messageDiv);
            scrollToBottom();
        }

        function addBotMessage(text, isError = false) {
            const chatContainer = document.getElementById('chatContainer');
            const messageDiv = createMessageElement('bot', text, null, isError);
            chatContainer.appendChild(messageDiv);
            scrollToBottom();
        }

        function showTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'flex';
            scrollToBottom();
        }

        function hideTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'none';
        }

        function scrollToBottom() {
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        }

        function updateSendButton() {
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = !messageInput.value.trim() && !selectedImage;
        }

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function selectImage() {
            document.getElementById('fileInput').click();
        }

        function handleImageSelect() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (file) {
                selectedImage = file;
                const preview = document.getElementById('imagePreview');
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    updateSendButton();
                };
                reader.readAsDataURL(file);
            }
        }

        function toggleRecording() {
            if (!recognition) {
                alert('Speech recognition is not supported in your browser.');
                return;
            }
            
            if (isRecording) {
                recognition.stop();
                stopRecording();
            } else {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Microphone access is not supported in your browser.');
                    return;
                }
                
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(function(stream) {
                        stream.getTracks().forEach(track => track.stop());
                        recognition.start();
                    })
                    .catch(function(error) {
                        console.error('Microphone error:', error);
                        if (error.name === 'NotAllowedError') {
                            alert('Microphone access denied.');
                        }
                    });
            }
        }

        function startRecording() {
            isRecording = true;
            document.getElementById('micBtn').classList.add('active');
            document.getElementById('recordingIndicator').style.display = 'flex';
        }

        function stopRecording() {
            isRecording = false;
            document.getElementById('micBtn').classList.remove('active');
            document.getElementById('recordingIndicator').style.display = 'none';
        }

        function toggleAutoSpeak() {
            autoSpeak = !autoSpeak;
            const speakerBtn = document.getElementById('speakerBtn');
            if (autoSpeak) {
                speakerBtn.classList.add('active');
            } else {
                speakerBtn.classList.remove('active');
            }
        }

        async function copyToClipboard(text) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    alert('Copied to clipboard!');
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.left = '-999999px';
                    textarea.style.top = '-999999px';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();
                    document.execCommand('copy');
                    textarea.remove();
                    alert('Copied to clipboard!');
                }
            } catch (err) {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy');
            }
        }

        function speakText(text) {
            if (!('speechSynthesis' in window)) {
                alert('Speech synthesis is not supported in your browser');
                return;
            }
            
            speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = speechRate;
            if (selectedVoice) utterance.voice = selectedVoice;
            speechSynthesis.speak(utterance);
        }

        function openSettings() {
            document.getElementById('settingsPanel').style.display = 'flex';
        }

        function closeSettings() {
            document.getElementById('settingsPanel').style.display = 'none';
        }

        function saveSettings() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (apiKey) {
                geminiApiKey = apiKey;
                localStorage.setItem('geminiApiKey', apiKey);
            }
            
            const voiceIndex = document.getElementById('voiceSelect').value;
            if (voiceIndex !== '') {
                selectedVoice = voices[parseInt(voiceIndex)];
                localStorage.setItem('selectedVoice', voiceIndex);
            }
            
            localStorage.setItem('speechRate', speechRate);
            localStorage.setItem('autoSpeak', autoSpeak);
            
            closeSettings();
            if (apiKey) {
                alert('Settings saved successfully!');
            }
        }

        function loadSettings() {
            const savedApiKey = localStorage.getItem('geminiApiKey');
            if (savedApiKey) {
                geminiApiKey = savedApiKey;
                document.getElementById('apiKeyInput').value = savedApiKey;
            }
            
            const savedVoiceIndex = localStorage.getItem('selectedVoice');
            if (savedVoiceIndex) {
                document.getElementById('voiceSelect').value = savedVoiceIndex;
                selectedVoice = voices[parseInt(savedVoiceIndex)];
            }
            
            const savedSpeechRate = localStorage.getItem('speechRate');
            if (savedSpeechRate) {
                speechRate = parseFloat(savedSpeechRate);
                document.getElementById('speechRate').value = speechRate;
                document.getElementById('rateValue').textContent = speechRate;
            }
            
            const savedAutoSpeak = localStorage.getItem('autoSpeak');
            if (savedAutoSpeak === 'true') {
                autoSpeak = true;
                document.getElementById('speakerBtn').classList.add('active');
            }
        }

        function saveChatHistory() {
            try {
                const chatContainer = document.getElementById('chatContainer');
                const messages = Array.from(chatContainer.children)
                    .filter(child => child.classList.contains('message'))
                    .map(msg => ({
                        sender: msg.classList.contains('user-message') ? 'user' : 'bot',
                        text: msg.querySelector('.message-text') ? msg.querySelector('.message-text').textContent : '',
                        timestamp: Date.now()
                    }));
                localStorage.setItem('chatHistory', JSON.stringify(messages.slice(-20)));
            } catch (error) {
                console.error('Error saving chat history:', error);
            }
        }

        function loadChatHistory() {
            try {
                const savedHistory = localStorage.getItem('chatHistory');
                if (savedHistory) {
                    const messages = JSON.parse(savedHistory);
                    const chatContainer = document.getElementById('chatContainer');
                    messages.forEach(msg => {
                        if (msg.text.trim()) {
                            const messageDiv = createMessageElement(msg.sender, msg.text);
                            chatContainer.appendChild(messageDiv);
                        }
                    });
                    scrollToBottom();
                }
            } catch (error) {
                console.error('Error loading chat history:', error);
            }
        }

        function toggleCall() {
            if (isInCall) {
                endCall();
            } else {
                startCall();
            }
        }

        function toggleVideoCall() {
            if (isInVideoCall) {
                endVideoCall();
            } else {
                startVideoCall();
            }
        }

        async function startCall() {
            if (!geminiApiKey) {
                alert('Please set your API key in Settings first.');
                return;
            }
            
            if (!continuousRecognition) {
                alert('Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
                return;
            }
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('Microphone access is not supported in your browser.');
                return;
            }
            
            // Check if online
            if (!navigator.onLine) {
                alert('You appear to be offline. Voice calls require an internet connection for speech recognition.');
                return;
            }
            
            try {
                console.log('Starting call - requesting microphone access...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log('Microphone access granted for call');
                microphonePermissionGranted = true;
                stream.getTracks().forEach(track => track.stop());
                
                isInCall = true;
                isMuted = false;
                conversationHistory = [];
                callStartTime = Date.now();
                isProcessingResponse = false;
                lastTranscript = '';
                lastResponseTime = 0;
                isAISpeaking = false;
                isListeningForUser = false;
                
                document.getElementById('callInterface').style.display = 'flex';
                document.getElementById('callBtn').textContent = 'üìû End Call';
                document.getElementById('callBtn').classList.add('calling');
                document.getElementById('callStatus').textContent = 'Connected';
                document.getElementById('muteBtn').classList.remove('muted');
                document.getElementById('muteBtn').innerHTML = 'üé§';
                
                startCallTimer();
                
                const greeting = 'Hi! I\'m ready to talk. How can I help you today?';
                conversationHistory.push({ role: 'assistant', content: greeting });
                addToCallTranscript('ai', greeting);
                
                speakTextInCall(greeting, () => {
                    if (isInCall) {
                        console.log('Starting listening after greeting...');
                        setTimeout(() => startListening(), 1500);
                    }
                });
            } catch (error) {
                console.error('Microphone access error:', error);
                if (error.name === 'NotAllowedError') {
                    alert('Microphone access denied. Please allow microphone access in your browser settings and refresh the page to try again.');
                } else if (error.name === 'NotFoundError') {
                    alert('No microphone found. Please connect a microphone and try again.');
                } else {
                    alert('Microphone error: ' + error.message + '. Please check your microphone settings and try again.');
                }
            }
        }

        function endCall() {
            console.log('Ending voice call...');
            isInCall = false;
            isMuted = false;
            isAISpeaking = false;
            isListeningForUser = false;
            
            speechSynthesis.cancel();
            
            if (continuousRecognition) {
                try {
                    continuousRecognition.stop();
                } catch (e) {}
            }
            
            if (callDurationInterval) {
                clearInterval(callDurationInterval);
            }
            
            const finalDuration = document.getElementById('callDuration').textContent || '00:00';
            
            document.getElementById('callInterface').style.display = 'none';
            document.getElementById('callBtn').textContent = 'üìû Call AI';
            document.getElementById('callBtn').classList.remove('calling');
            document.getElementById('listeningIndicator').style.display = 'none';
            document.getElementById('speakingIndicator').style.display = 'none';
            
            if (conversationHistory.length > 1) {
                addCallSummaryToChat(finalDuration);
            } else {
                addCallEndedToChat(finalDuration);
            }
            
            console.log('Voice call ended successfully');
        }

        function startListening() {
            console.log('startListening called', { isInCall, isMuted, isAISpeaking, isProcessingResponse, hasContinuous: !!continuousRecognition });
            
            if (!isInCall || isMuted || isAISpeaking || !continuousRecognition || isProcessingResponse) {
                console.log('Cannot start listening - conditions not met');
                return;
            }
            
            try {
                console.log('Starting call speech recognition...');
                isListeningForUser = true;
                document.getElementById('listeningIndicator').style.display = 'flex';
                document.getElementById('speakingIndicator').style.display = 'none';
                
                try {
                    continuousRecognition.stop();
                    console.log('Stopped previous recognition');
                } catch (e) {
                    console.log('No previous recognition to stop');
                }
                
                setTimeout(() => {
                    if (isInCall && !isMuted && !isAISpeaking && !isProcessingResponse) {
                        try {
                            console.log('Actually starting continuous recognition...');
                            continuousRecognition.start();
                            console.log('Continuous recognition started successfully');
                        } catch (error) {
                            console.error('Error starting recognition in timeout:', error);
                            if (error.name === 'InvalidStateError') {
                                console.log('Recognition already running, continuing...');
                            } else {
                                alert('Speech recognition failed to start. Please check your microphone and try again.');
                            }
                        }
                    } else {
                        console.log('Conditions changed, not starting recognition');
                    }
                }, 500);
            } catch (error) {
                console.error('Error starting call speech recognition:', error);
                document.getElementById('listeningIndicator').style.display = 'none';
                alert('Failed to start speech recognition. Please check your microphone permissions.');
            }
        }

        function stopListening() {
            isListeningForUser = false;
            document.getElementById('listeningIndicator').style.display = 'none';
            if (continuousRecognition) {
                try {
                    continuousRecognition.stop();
                } catch (e) {}
            }
        }

        function speakTextInCall(text, onComplete) {
            if (!isInCall) return;
            
            isAISpeaking = true;
            stopListening();
            
            document.getElementById('speakingIndicator').style.display = 'flex';
            document.getElementById('listeningIndicator').style.display = 'none';
            
            speechSynthesis.cancel();
            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.rate = speechRate;
            if (selectedVoice) {
                currentUtterance.voice = selectedVoice;
            }
            
            currentUtterance.onend = () => {
                isAISpeaking = false;
                document.getElementById('speakingIndicator').style.display = 'none';
                if (onComplete) onComplete();
            };
            
            currentUtterance.onerror = () => {
                isAISpeaking = false;
                document.getElementById('speakingIndicator').style.display = 'none';
                if (onComplete) onComplete();
            };
            
            speechSynthesis.speak(currentUtterance);
        }

        async function handleCallUserInput(transcript) {
            if (!isInCall || isAISpeaking || isProcessingResponse) return;
            
            const isDuplicate = conversationHistory.length > 0 &&
                conversationHistory[conversationHistory.length - 1].role === 'user' &&
                conversationHistory[conversationHistory.length - 1].content.toLowerCase() === transcript.toLowerCase();
            
            if (isDuplicate) {
                return;
            }
            
            isProcessingResponse = true;
            conversationHistory.push({ role: 'user', content: transcript });
            addToCallTranscript('user', transcript);
            stopListening();
            
            try {
                const response = await callGeminiAPIForCall(transcript);
                
                if (response && response.candidates && response.candidates[0]) {
                    const aiResponse = response.candidates[0].content.parts[0].text;
                    conversationHistory.push({ role: 'assistant', content: aiResponse });
                    addToCallTranscript('ai', aiResponse);
                    
                    speakTextInCall(aiResponse, () => {
                        isProcessingResponse = false;
                        if (isInCall && !isMuted) {
                            setTimeout(() => startListening(), 1000);
                        }
                    });
                } else {
                    throw new Error('Invalid response format');
                }
            } catch (error) {
                console.error('Error in call processing:', error);
                const errorMessage = 'Sorry, I didn\'t catch that. Could you please repeat?';
                addToCallTranscript('ai', errorMessage);
                
                speakTextInCall(errorMessage, () => {
                    isProcessingResponse = false;
                    if (isInCall && !isMuted) {
                        setTimeout(() => startListening(), 1000);
                    }
                });
            }
        }

        async function callGeminiAPIForCall(text) {
            const parts = [{ text: systemInstructions + '\n\nUser: ' + text }];
            
            try {
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + geminiApiKey, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: parts }],
                        generationConfig: { temperature: 0.7, topK: 40, topP: 0.95, maxOutputTokens: 512 }
                    })
                });
                
                if (!response.ok) {
                    throw new Error('API Error ' + response.status);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Call API failed:', error);
                throw error;
            }
        }

        function addToCallTranscript(sender, text) {
            const transcript = document.getElementById('callTranscript');
            const entry = document.createElement('div');
            entry.className = 'transcript-entry transcript-' + sender;
            entry.innerHTML = '<strong>' + (sender === 'user' ? 'You' : 'AI') + ':</strong> ' + text;
            transcript.appendChild(entry);
            transcript.scrollTop = transcript.scrollHeight;
        }

        function startCallTimer() {
            callDurationInterval = setInterval(() => {
                if (isInCall && callStartTime) {
                    const duration = Math.floor((Date.now() - callStartTime) / 1000);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    document.getElementById('callDuration').textContent = 
                        minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
                }
            }, 1000);
        }

        function toggleMute() {
            isMuted = !isMuted;
            const muteBtn = document.getElementById('muteBtn');
            
            if (isMuted) {
                muteBtn.classList.add('muted');
                muteBtn.innerHTML = 'üé§üö´';
                stopListening();
            } else {
                muteBtn.classList.remove('muted');
                muteBtn.innerHTML = 'üé§';
                if (isInCall && !isAISpeaking) {
                    setTimeout(() => startListening(), 500);
                }
            }
        }

        function copyCallTranscript() {
            const transcript = document.getElementById('callTranscript');
            let text = 'Call Transcript:\n\n';
            const entries = transcript.querySelectorAll('.transcript-entry');
            entries.forEach(entry => {
                text += entry.textContent + '\n';
            });
            copyToClipboard(text);
        }

        function speakCallTranscript() {
            const transcript = document.getElementById('callTranscript');
            let text = 'Reading call transcript. ';
            const entries = transcript.querySelectorAll('.transcript-entry');
            entries.forEach(entry => {
                text += entry.textContent + '. ';
            });
            speakText(text);
        }

        function addCallSummaryToChat(duration) {
            const chatContainer = document.getElementById('chatContainer');
            const exchanges = Math.floor(conversationHistory.length / 2);
            const summaryText = 'üìû Voice Call Summary:\n\n' +
                '‚è∞ Duration: ' + duration + '\n' +
                'üí¨ Exchanges: ' + exchanges + ' back-and-forth conversations\n' +
                'ü§ñ Topics discussed: ' + (conversationHistory.length > 2 ? 'Various questions and responses' : 'Brief conversation') + '\n\n' +
                'Call ended successfully. Feel free to start another call or continue chatting!';
            const summaryDiv = createMessageElement('bot', summaryText);
            chatContainer.appendChild(summaryDiv);
            scrollToBottom();
        }

        function addCallEndedToChat(duration) {
            const chatContainer = document.getElementById('chatContainer');
            const summaryText = 'üìû Voice Call Ended\n\n' +
                '‚è∞ Duration: ' + duration + '\n' +
                'üí¨ Status: Call ended without conversation\n\n' +
                'Ready for your next call or message!';
            const summaryDiv = createMessageElement('bot', summaryText);
            chatContainer.appendChild(summaryDiv);
            scrollToBottom();
        }

        async function startVideoCall() {
            if (!geminiApiKey) {
                alert('Please set your API key in Settings first.');
                return;
            }
            
            if (!continuousRecognition) {
                alert('Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
                return;
            }
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('Camera and microphone access is not supported in your browser.');
                return;
            }
            
            // Check if online
            if (!navigator.onLine) {
                alert('You appear to be offline. Video calls require an internet connection for speech recognition.');
                return;
            }
            
            try {
                console.log('Starting video call...');
                
                if (typeof currentCamera === 'undefined' || !currentCamera) {
                    currentCamera = 'user';
                    console.log('Initialized currentCamera to default:', currentCamera);
                }
                
                console.log('Using camera:', currentCamera);
                
                const constraints = {
                    video: {
                        facingMode: currentCamera,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                };
                
                console.log('Requesting media with constraints:', constraints);
                videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                const videoElement = document.getElementById('userVideo');
                videoElement.srcObject = videoStream;
                
                isInVideoCall = true;
                isCameraOn = true;
                isMuted = false;
                conversationHistory = [];
                callStartTime = Date.now();
                analysisCount = 0;
                isProcessingResponse = false;
                lastTranscript = '';
                lastResponseTime = 0;
                microphonePermissionGranted = true;
                
                document.getElementById('videoCallInterface').style.display = 'flex';
                document.getElementById('videoCallBtn').textContent = 'üìπ End Video Call';
                document.getElementById('videoCallBtn').classList.add('calling');
                document.getElementById('videoCallStatus').textContent = 'Connected';
                document.getElementById('videoMuteBtn').classList.remove('muted');
                document.getElementById('videoMuteBtn').innerHTML = 'üé§';
                document.getElementById('videoCameraBtn').classList.remove('off');
                document.getElementById('videoCameraBtn').innerHTML = 'üìπ';
                
                console.log('Video call started successfully');
                
                await enumerateCameras();
                
                startVideoCallTimer();
                
                videoAnalysisInterval = setInterval(() => {
                    if (isInVideoCall && isCameraOn && !isAISpeaking && !isProcessingResponse) {
                        analyzeVideoAutomatically();
                    }
                }, 30000);
                
                const greeting = 'Hi! I can see and hear you now. How can I help you today?';
                conversationHistory.push({ role: 'assistant', content: greeting });
                addToVideoTranscript('ai', greeting);
                
                speakTextInVideoCall(greeting, () => {
                    if (isInVideoCall) {
                        setTimeout(() => startVideoListening(), 1000);
                    }
                });
            } catch (error) {
                console.error('Error starting video call:', error);
                
                if (error.name === 'NotAllowedError') {
                    alert('Camera and microphone access are required for video calls. Please allow access in your browser settings and try again.');
                } else if (error.name === 'NotFoundError') {
                    alert('Camera or microphone not found. Please connect your devices and try again.');
                } else if (error.name === 'OverconstrainedError') {
                    console.log('Camera constraints not supported, trying basic constraints...');
                    try {
                        const basicConstraints = { video: true, audio: true };
                        videoStream = await navigator.mediaDevices.getUserMedia(basicConstraints);
                        
                        const videoElement = document.getElementById('userVideo');
                        videoElement.srcObject = videoStream;
                        
                        currentCamera = 'user';
                        isInVideoCall = true;
                        isCameraOn = true;
                        
                        document.getElementById('videoCallInterface').style.display = 'flex';
                        document.getElementById('videoCallBtn').textContent = 'üìπ End Video Call';
                        document.getElementById('videoCallBtn').classList.add('calling');
                        
                        alert('Started video call with basic camera settings.');
                    } catch (basicError) {
                        alert('Failed to start video call: ' + basicError.message);
                    }
                } else {
                    alert('Failed to start video call: ' + error.message);
                }
            }
        }

        function endVideoCall() {
            console.log('Ending video call...');
            isInVideoCall = false;
            isCameraOn = false;
            isMuted = false;
            isAISpeaking = false;
            isListeningForUser = false;
            
            speechSynthesis.cancel();
            
            if (continuousRecognition) {
                try {
                    continuousRecognition.stop();
                } catch (e) {}
            }
            
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            
            if (videoAnalysisInterval) {
                clearInterval(videoAnalysisInterval);
            }
            
            if (callDurationInterval) {
                clearInterval(callDurationInterval);
            }
            
            const finalDuration = document.getElementById('videoCallDuration').textContent || '00:00';
            
            document.getElementById('videoCallInterface').style.display = 'none';
            document.getElementById('videoCallBtn').textContent = 'üìπ Video Call';
            document.getElementById('videoCallBtn').classList.remove('calling');
            document.getElementById('listeningIndicator').style.display = 'none';
            document.getElementById('speakingIndicator').style.display = 'none';
            document.getElementById('videoAnalysisIndicator').style.display = 'none';
            
            const switchBtn = document.getElementById('switchCameraBtn');
            if (switchBtn) {
                switchBtn.disabled = false;
                switchBtn.innerHTML = 'üîÑ';
            }
            
            if (conversationHistory.length > 1) {
                addVideoCallSummaryToChat(finalDuration);
            } else {
                addVideoCallEndedToChat(finalDuration);
            }
            
            console.log('Video call ended successfully');
        }

        function startVideoListening() {
            if (!isInVideoCall || isMuted || isAISpeaking || !continuousRecognition || isProcessingResponse) {
                return;
            }
            
            try {
                isListeningForUser = true;
                document.getElementById('listeningIndicator').style.display = 'flex';
                document.getElementById('speakingIndicator').style.display = 'none';
                
                try {
                    continuousRecognition.stop();
                } catch (e) {}
                
                setTimeout(() => {
                    if (isInVideoCall && !isMuted && !isAISpeaking && !isProcessingResponse) {
                        try {
                            continuousRecognition.start();
                        } catch (error) {
                            console.error('Error starting video recognition:', error);
                        }
                    }
                }, 300);
            } catch (error) {
                console.error('Error starting video call speech recognition:', error);
            }
        }

        function stopVideoListening() {
            isListeningForUser = false;
            document.getElementById('listeningIndicator').style.display = 'none';
            if (continuousRecognition) {
                try {
                    continuousRecognition.stop();
                } catch (e) {}
            }
        }

        function speakTextInVideoCall(text, onComplete) {
            if (!isInVideoCall) return;
            
            isAISpeaking = true;
            stopVideoListening();
            
            document.getElementById('speakingIndicator').style.display = 'flex';
            document.getElementById('listeningIndicator').style.display = 'none';
            
            speechSynthesis.cancel();
            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.rate = speechRate;
            if (selectedVoice) {
                currentUtterance.voice = selectedVoice;
            }
            
            currentUtterance.onend = () => {
                isAISpeaking = false;
                document.getElementById('speakingIndicator').style.display = 'none';
                if (onComplete) onComplete();
            };
            
            currentUtterance.onerror = () => {
                isAISpeaking = false;
                document.getElementById('speakingIndicator').style.display = 'none';
                if (onComplete) onComplete();
            };
            
            speechSynthesis.speak(currentUtterance);
        }

        async function handleVideoCallUserInput(transcript) {
            if (!isInVideoCall || isAISpeaking || isProcessingResponse) return;
            
            const isDuplicate = conversationHistory.length > 0 &&
                conversationHistory[conversationHistory.length - 1].role === 'user' &&
                conversationHistory[conversationHistory.length - 1].content.toLowerCase() === transcript.toLowerCase();
            
            if (isDuplicate) {
                return;
            }
            
            isProcessingResponse = true;
            conversationHistory.push({ role: 'user', content: transcript });
            addToVideoTranscript('user', transcript);
            stopVideoListening();
            
            try {
                const response = await callGeminiAPIForCall(transcript);
                
                if (response && response.candidates && response.candidates[0]) {
                    const aiResponse = response.candidates[0].content.parts[0].text;
                    conversationHistory.push({ role: 'assistant', content: aiResponse });
                    addToVideoTranscript('ai', aiResponse);
                    
                    speakTextInVideoCall(aiResponse, () => {
                        isProcessingResponse = false;
                        if (isInVideoCall && !isMuted) {
                            setTimeout(() => startVideoListening(), 1000);
                        }
                    });
                } else {
                    throw new Error('Invalid response format');
                }
            } catch (error) {
                console.error('Error in video call processing:', error);
                const errorMessage = 'Sorry, I didn\'t catch that. Could you please repeat?';
                addToVideoTranscript('ai', errorMessage);
                
                speakTextInVideoCall(errorMessage, () => {
                    isProcessingResponse = false;
                    if (isInVideoCall && !isMuted) {
                        setTimeout(() => startVideoListening(), 1000);
                    }
                });
            }
        }

        function addToVideoTranscript(sender, text) {
            const transcript = document.getElementById('videoTranscript');
            const entry = document.createElement('div');
            entry.className = 'transcript-entry transcript-' + sender;
            entry.innerHTML = '<strong>' + (sender === 'user' ? 'You' : 'AI') + ':</strong> ' + text;
            transcript.appendChild(entry);
            transcript.scrollTop = transcript.scrollHeight;
        }

        function startVideoCallTimer() {
            callDurationInterval = setInterval(() => {
                if (isInVideoCall && callStartTime) {
                    const duration = Math.floor((Date.now() - callStartTime) / 1000);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    document.getElementById('videoCallDuration').textContent = 
                        minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
                }
            }, 1000);
        }

        function toggleVideoMute() {
            isMuted = !isMuted;
            const muteBtn = document.getElementById('videoMuteBtn');
            
            if (isMuted) {
                muteBtn.classList.add('muted');
                muteBtn.innerHTML = 'üé§üö´';
                stopVideoListening();
            } else {
                muteBtn.classList.remove('muted');
                muteBtn.innerHTML = 'üé§';
                if (isInVideoCall && !isAISpeaking) {
                    setTimeout(() => startVideoListening(), 500);
                }
            }
        }

        function toggleCamera() {
            isCameraOn = !isCameraOn;
            const cameraBtn = document.getElementById('videoCameraBtn');
            const videoElement = document.getElementById('userVideo');
            
            if (isCameraOn) {
                cameraBtn.classList.remove('off');
                cameraBtn.innerHTML = 'üìπ';
                if (videoStream) {
                    videoElement.srcObject = videoStream;
                }
            } else {
                cameraBtn.classList.add('off');
                cameraBtn.innerHTML = 'üìπüö´';
                videoElement.srcObject = null;
            }
        }

        function captureAndAnalyze() {
            if (!isInVideoCall || !isCameraOn) {
                alert('Video call and camera must be active for analysis.');
                return;
            }
            
            const video = document.getElementById('userVideo');
            const canvas = document.getElementById('videoCaptureCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            document.getElementById('videoAnalysisIndicator').style.display = 'flex';
            
            canvas.toBlob(async (blob) => {
                try {
                    const response = await callGeminiAPI('Please analyze what you see in this image and provide feedback on what I\'m doing.', blob);
                    
                    if (response && response.candidates && response.candidates[0]) {
                        const analysisResult = response.candidates[0].content.parts[0].text;
                        addToVideoTranscript('ai', 'üì∏ Analysis: ' + analysisResult);
                        
                        speakTextInVideoCall('I can see ' + analysisResult, () => {
                            if (isInVideoCall && !isMuted) {
                                setTimeout(() => startVideoListening(), 1000);
                            }
                        });
                    }
                } catch (error) {
                    console.error('Video analysis error:', error);
                    addToVideoTranscript('ai', 'Sorry, I couldn\'t analyze the image.');
                } finally {
                    document.getElementById('videoAnalysisIndicator').style.display = 'none';
                }
            }, 'image/jpeg', 0.8);
        }

        function analyzeVideoAutomatically() {
            if (!isInVideoCall || !isCameraOn || isAISpeaking || isProcessingResponse) return;
            
            analysisCount++;
            
            if (analysisCount % 2 === 0) {
                const video = document.getElementById('userVideo');
                const canvas = document.getElementById('videoCaptureCanvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                canvas.toBlob(async (blob) => {
                    try {
                        const response = await callGeminiAPI('Briefly describe what you see in this image. Keep it under 20 words.', blob);
                        
                        if (response && response.candidates && response.candidates[0]) {
                            const analysisResult = response.candidates[0].content.parts[0].text;
                            console.log('Auto-analysis:', analysisResult);
                        }
                    } catch (error) {
                        console.error('Auto video analysis error:', error);
                    }
                }, 'image/jpeg', 0.6);
            }
        }

        function copyVideoTranscript() {
            const transcript = document.getElementById('videoTranscript');
            let text = 'Video Call Transcript:\n\n';
            const entries = transcript.querySelectorAll('.transcript-entry');
            entries.forEach(entry => {
                text += entry.textContent + '\n';
            });
            copyToClipboard(text);
        }

        function speakVideoTranscript() {
            const transcript = document.getElementById('videoTranscript');
            let text = 'Reading video call transcript. ';
            const entries = transcript.querySelectorAll('.transcript-entry');
            entries.forEach(entry => {
                text += entry.textContent + '. ';
            });
            speakText(text);
        }

        function addVideoCallSummaryToChat(duration) {
            const chatContainer = document.getElementById('chatContainer');
            const exchanges = Math.floor(conversationHistory.length / 2);
            const summaryText = 'üìπ Video Call Summary:\n\n' +
                '‚è∞ Duration: ' + duration + '\n' +
                'üí¨ Exchanges: ' + exchanges + ' back-and-forth conversations\n' +
                'üì∏ Video Analysis: ' + analysisCount + ' automatic analysis performed\n' +
                'üé• Camera: ' + (currentCamera === 'environment' ? 'Back camera used' : 'Front camera used') + '\n' +
                'ü§ñ Topics discussed: ' + (conversationHistory.length > 2 ? 'Various questions with visual context' : 'Brief video conversation') + '\n\n' +
                'Video call ended successfully. Feel free to start another call or continue chatting!';
            const summaryDiv = createMessageElement('bot', summaryText);
            chatContainer.appendChild(summaryDiv);
            scrollToBottom();
        }

        function addVideoCallEndedToChat(duration) {
            const chatContainer = document.getElementById('chatContainer');
            const summaryText = 'üìπ Video Call Ended\n\n' +
                '‚è∞ Duration: ' + duration + '\n' +
                'üí¨ Status: Video call ended without conversation\n' +
                'üì∏ Analysis: ' + analysisCount + ' automatic scans performed\n' +
                'üé• Camera: ' + (currentCamera === 'environment' ? 'Back camera' : 'Front camera') + '\n\n' +
                'Ready for your next video call or message!';
            const summaryDiv = createMessageElement('bot', summaryText);
            chatContainer.appendChild(summaryDiv);
            scrollToBottom();
        }

        console.log('AI Assistant with complete features loaded successfully');

        window.addEventListener('beforeunload', function() {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            if (continuousRecognition) {
                try { continuousRecognition.stop(); } catch (e) {}
            }
        });
    </script>
</body>
</html>
              